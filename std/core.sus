
// For now these builtin declarations must be in this order, because they're constants in the code. 
// We'll get a better system for this at some point

/// The decider of truth and falsity
__builtin__ struct bool {}
// An integer of variable size.
__builtin__ struct int #(int FROM, int TO) {}

/// Single precision IEEE 32-bit float. Operators are provided by external libraries, but it's defined here for convenience. 
__builtin__ struct float {}

/// Single precision IEEE 64-bit double-precision float. Operators are provided by external libraries, but it's defined here for convenience. 
__builtin__ struct double {}

/// For intentionally triggering an ICE for debugging. It is a constant that crashes the compiler when it is evaluated
__builtin__ const bool __crash_compiler {}

/// True, as in '1'
__builtin__ const bool true {}
/// False, as in '0'
__builtin__ const bool false {}

/// Fails to execute iff `C == false`
__builtin__ const bool assert #(bool C) {}

/// Returns the size of the given type, in bits. 
///
/// `sizeof #(T: type bool) = 1`
/// `sizeof #(T: type bool[50]) = 50`
/// `sizeof #(T: type int[10][10]) = 3200`
__builtin__ const int sizeof #(T) {}


/// Computes the Log2 of a value, rounded up. 
/// 
/// Typically used to find the size in bits that the address would need to be to address into a memory of size V. 
///
/// Requires V > 0
///
/// `clog2 #(V: 15) = 4`
/// `clog2 #(V: 16) = 4`
/// `clog2 #(V: 17) = 5`
__builtin__ const int clog2 #(int V) {}

/// Computes `2^E` at compile-time
__builtin__ const int pow2 #(int E) {}

/// Computes `B^E` at compile-time
__builtin__ const int pow #(int B, int E) {}

/// Computes `N!`
__builtin__ const int factorial #(int N) {}

/// Computes `N! / (N - K)!`. for `0 <= K <= N`
__builtin__ const int falling_factorial #(int N, int K) {}

/// Computes `N! / (K! * (N - K)!)`. for `0 <= K <= N`
__builtin__ const int comb #(int N, int K) {}

/// `Result == V`, but this prevents this from being included in the inference parameters. 
__builtin__ const int noinfer #(int V) {}

/// Unsafe builtin to circumvent the Latency Counting System. Connects `out` to `in` without adding the requisite latency
/// Or: used for negative latencies, for instance to implement Almost-Full FIFOs, stateful for loops, etc. 
__builtin__ module LatencyOffset #(T, int OFFSET) {
    interface LatencyOffset : T in'0 -> T out'OFFSET
}

/// Unsafe builtin to connect wires from different domains. 
/// Important: Does not perform any kind of Clock Domain Crossing!
__builtin__ module CrossDomain #(T) {
    domain in_clk
    input T in'0
    domain out_clk
    output T out'0
}
/// Unsafe builtin to connect wires from different domains. 
/// Important: Does not perform any kind of Clock Domain Crossing!
module CrossAction #(T) {
    CrossDomain #(T: type bool) cross_valid
    CrossDomain #(T) cross_data
    domain in_clk
    action in'0 : T data_in'0 {
        cross_valid.in = true
        cross_data.in = data_in
    } else {
        cross_valid.in = false
    }
    domain out_clk
    trigger out'0 : T data_out'0

    when cross_valid.out {
        out(cross_data.out)
    }
}
/// Unsafe builtin to connect wires from different domains. 
/// Important: Does not perform any kind of Clock Domain Crossing!
module CrossActionNoData {
    CrossDomain #(T: type bool) cross_valid
    domain in_clk
    action in'0 {
        cross_valid.in = true
    } else {
        cross_valid.in = false
    }
    domain out_clk
    trigger out'0

    when cross_valid.out {
        out()
    }
}
module LatencyOffsetAction #(T, int OFFSET, int DATA_DELAY) {
    T stored_data
    bool is_valid
    
    action in'0 : T din'DATA_DELAY {
        is_valid = true
        stored_data = din
    } else {
        is_valid = false
    }

    trigger out'OFFSET : T dout'OFFSET+DATA_DELAY

    when LatencyOffset #(OFFSET)(is_valid) {
        out(LatencyOffset #(OFFSET)(stored_data))
    }
}

module LatencyOffsetActionNoData #(int OFFSET) {
    bool is_valid
    
    action in'0 {
        is_valid = true
    } else {
        is_valid = false
    }

    trigger out'OFFSET

    when LatencyOffset #(OFFSET)(is_valid) {
        out()
    }
}


/// Convert signed int to 2s complement bits. (`bits[0]` is `value`'s Least Significant Bit)
///
/// Requires `-pow2 #(E: NUM_BITS - 1) <= value < pow2 #(E: NUM_BITS - 1)`
///
/// Runtime equivalent of [IntToBitsGen]
__builtin__ module IntToBits #(int NUM_BITS) {
    interface IntToBits : int #(FROM: -pow2 #(E: NUM_BITS - 1), TO: pow2 #(E: NUM_BITS - 1)) value'0 -> bool[NUM_BITS] bits'0
}
/// Convert int to unsigned bits. (`bits[0]` is `value`'s Least Significant Bit)
///
/// Requires `0 <= value < pow2 #(E: NUM_BITS)`
///
/// Runtime equivalent of [UIntToBitsGen]
__builtin__ module UIntToBits #(int NUM_BITS) {
    interface UIntToBits : int #(FROM: 0, TO: pow2 #(E: NUM_BITS)) value'0 -> bool[NUM_BITS] bits'0
}
/// Convert 2s complement bits to a signed int. (`bits[0]` is `value`'s Least Significant Bit)
///
/// Creates an int in the range `-pow2 #(E: NUM_BITS - 1) <= value < pow2 #(E: NUM_BITS - 1)`
///
/// Runtime equivalent of [BitsToIntGen]
__builtin__ module BitsToInt #(int NUM_BITS) {
    interface BitsToInt : bool[NUM_BITS] bits'0 -> int #(FROM: -pow2 #(E: NUM_BITS - 1), TO: pow2 #(E: NUM_BITS - 1)) value'0
}
/// Convert unsigned bits to an unsigned int. (`bits[0]` is `value`'s Least Significant Bit)
///
/// Creates an int in the range `0 <= value < pow2 #(E: NUM_BITS)`
///
/// Runtime equivalent of [BitsToUIntGen]
__builtin__ module BitsToUInt #(int NUM_BITS) {
    interface BitsToUInt : bool[NUM_BITS] bits'0 -> int #(FROM: 0, TO: pow2 #(E: NUM_BITS)) value'0
}

/// Convert gen int to 2s complement bits. (`RESULT[0]` is `V`'s Least Significant Bit)
///
/// Requires `-pow2 #(E: NUM_BITS - 1) <= V < pow2 #(E: NUM_BITS - 1)`
///
/// Generative equivalent of [IntToBits]
__builtin__ const bool[NUM_BITS] IntToBitsGen #(int NUM_BITS, int V) {}
/// Convert gen int to unsigned bits. (`RESULT[0]` is `V`'s Least Significant Bit)
///
/// Requires `0 <= V < pow2 #(E: NUM_BITS)`
///
/// Generative equivalent of [UIntToBits]
__builtin__ const bool[NUM_BITS] UIntToBitsGen #(int NUM_BITS, int V) {}
/// Convert gen 2s complement bits to a gen signed int. (`BITS[0]` is `V`'s Least Significant Bit)
///
/// Creates an int in the range `-pow2 #(E: NUM_BITS - 1) <= value < pow2 #(E: NUM_BITS - 1)`
///
/// Generative equivalent of [BitsToInt]
__builtin__ const int BitsToIntGen #(int NUM_BITS, bool[NUM_BITS] BITS) {}
/// Convert gen unsigned bits to a gen unsigned int. (`BITS[0]` is `V`'s Least Significant Bit)
///
/// Creates an int in the range `0 <= value < pow2 #(E: NUM_BITS)`
///
/// Generative equivalent of [BitsToUInt]
__builtin__ const int BitsToUIntGen #(int NUM_BITS, bool[NUM_BITS] BITS) {}


__builtin__ module transmute_to_bits #(T) {
    interface transmute_to_bits : T value'0 -> bool[sizeof #(T)] bits'0
}

__builtin__ module transmute_from_bits #(T) {
    interface transmute_from_bits : bool[sizeof #(T)] bits'0 -> T value'0
}

module transmute #(T1, T2) {
    interface transmute : T1 a'0 -> T2 b'0

    gen int SIZE = sizeof #(T: type T1)
    
    assert #(C: SIZE == sizeof #(T: type T2))

    bool[SIZE] as_bits = transmute_to_bits #(T: type T1)(a)
    b = transmute_from_bits #(T: type T2)(as_bits)
}

__builtin__ module unsafe_int_cast #(int FROM_I, int TO_I, int FROM, int TO) {
    interface unsafe_int_cast : int#(FROM: FROM_I, TO: TO_I) in'0 -> int#(FROM, TO) out'0
}
