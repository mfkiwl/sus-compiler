
// Recursive Tree Add module recurses smaller copies of itself. 
module TreeAdder #(int WIDTH) {
	interface TreeAdder : int[WIDTH] values'0 -> int total

	if WIDTH == 0 {
		// Have to explicitly give zero a latency count. 
		// Otherwise total's latency can't be determined. 
		int zero'0 = 0
		total = zero
	} else if WIDTH == 1 {
		total = values[0]
	} else {
		gen int L_SZ = WIDTH / 2
		gen int R_SZ = WIDTH - L_SZ

		int[L_SZ] left_part, int[R_SZ] right_part = SplitAt(values)

		int left_total = TreeAdder(left_part)
		int right_total = TreeAdder(right_part)
		
		// Can add pipelining registers here too. 
		// Latency Counting will figure it out.
		reg total = left_total + right_total
	}
}

module use_TreeAdder {
    TreeAdder #(WIDTH: 20) t
}

module TreeAdderBaseCase #(int WIDTH) {
	interface TreeAdderBaseCase : int[WIDTH] values'0 -> int total

    gen int L_SZ = WIDTH / 2
    gen int R_SZ = WIDTH - L_SZ

    int[L_SZ] left_part, int[R_SZ] right_part = SplitAt(values)

    int left_total = TreeAdder(left_part)
    int right_total = TreeAdder(right_part)
    
    // Can add pipelining registers here too. 
    // Latency Counting will figure it out.
    reg total = left_total + right_total
}


module pairwiseMultiply #(int SIZE) {
	interface pairwiseMultiply: int[SIZE] a -> int[SIZE-1] out

	for int I in 0..SIZE-1 {
		out[I] = a[I] * a[I+1]
	}
}



module conditionalBindings {

    FIFO #(DEPTH: 20) fifo

    when fifo.ready { // Trigger
        fifo.push(3) // Action
    }

    // Query (Action + Trigger)
    when fifo.pop() : int data {
        // Do stuff with data
    }


    fifo.data_in = 3
}



module use_splitAt {
    input int[20] arr
    output int x

    SplitAt #(T: type int, SIZE: 20, SPLIT_POINT: 2) spl
    int[2] a, int[18] b = spl(arr)

    int[2] c, int[18] d = SplitAt(arr)

    x = a[0] + b[0] + c[0] + d[0]
}


module pairwiseMultiplyFlattened #(int SIZE) {
	interface pairwiseMultiplyFlattened: int[SIZE] a -> int[SIZE-1] out

    gen int _0 = SIZE-1
	for int I in 0.._0 {
        int _1 = a[I]
        gen int _2 = I+1
        int _3 = a[_2]
		out[I] = _1 * _3
	}
}



module pairwiseMultiplyExecuted /* #(int SIZE = 3)*/ {
	interface pairwiseMultiplyExecuted: int[3] a -> int[2] out

    out[0] = a[0] * a[1]
    out[1] = a[1] * a[2]
}



module BRAMShiftReg #(T, int LATENCY) {
    interface BRAMShiftReg: T d_in'0 -> T d_out'LATENCY

    state T[LATENCY] memory
    state int idx = 0

    T out_data = memory[idx]
    memory[idx] = d_in

    idx = (idx + 1) % LATENCY

    d_out = LatencyOffset #(OFFSET: LATENCY)(out_data)
}

module use_bram {
    BRAMShiftReg #(T: type bool[3], LATENCY: 10) b
}



module for_loop {
    input float[4] as
    input float[4] bs 
    output float[4] rs

    for int i in 0..4 {
        rs[i] = fp_mul(as[i], bs[i])
    }
}


module from_bool {
    input bool b
    output int i
    
    when b {
        i = 1
    } else {
        i = 0
    }
}

module axis #(T) {
    action send_single : T data{}
    action send_burst : T data2{}
}

module axi_send #(T) {
    input T data
    
    axis axis
    if sizeof#(T) <= 32 {
        axis.send_single(data)
    } else {
        axis.send_burst(data)
    }
}

module bounded_ints {
    input int#(FROM: 0, TO: 5) v
    int v_2

    when v == 3 {
        v_2 = 10
    } else {
        v_2 = v
    }


    output int x = v_2
}

module memory#(T, int DEPTH) {
    T[DEPTH] mem

    action write: int#(FROM: 0, TO: DEPTH) addr, T data {
        mem[addr] = data
    }
    action read: int#(FROM: 0, TO: DEPTH) addrb -> T datab {
        datab = mem[addrb]
    }
}

module use_memory {
    memory#(T: type bool[20], DEPTH: 5) mem

    state int cur_idx
    action get_next : -> bool[20] d {
        d = mem.read(cur_idx)
        cur_idx = (cur_idx + 1) % 5
    }
}

module raw_ddr_memory #(T) {
    domain user_side
    action read : int#(FROM: 0, TO: 1000) addr {
        //...
    }
    trigger read_ready : -> T data {
        //...
    }

    domain ddr_side
    // ... god knows this'll be a mess
}

module instruction_decode {
    action decode : bool[16] instr_bits {
        //...

        trigger add : 
            int#(FROM: 0, TO: 8) reg_a,
            int#(FROM: 0, TO: 8) reg_b,
            int#(FROM: 0, TO: 8) reg_tgt {
            // ...
        }
        trigger load_imm8 : 
            bool[8] data,
            int#(FROM: 0, TO: 8) reg_tgt {
            // ...
        }
        trigger jump :
            int#(FROM: 0, TO: 256) target {
            // ...
        }

        when instr_bits[0] && instr_bits[1] {
            add(3, 4, 5)//...
        }
    }
}

module use_decode {
    input bool[16] instr

    instruction_decode decoder

    decoder.decode(instr)

    when decoder.add : int a, int b, int r {
        // execute add
    }
    when decoder.load_imm8 : bool[8] v, int r {
        // execute add
    }
    when decoder.jump : int tgt {
        // execute add
    }
}

module iterator#(int MAX) {
    state int cur

    action start {
        cur = 0
    }
    trigger iter : int v, bool last

    when cur != MAX {
        iter(cur, cur == MAX - 1)
        cur = (cur + 1) % MAX
    }
}

module use_iter {
    int[6] terms = [5, 7, -9, 6, 5, 2]
    state int total

    iterator#(MAX: 6) iter
    action sum_up {
        total = 0
        iter.start()
    }
    trigger done : int sum
    when iter.iter : int idx, bool last {
        int new_total = (total + terms[idx]) % 256
        when last {
            done(new_total)
        }
        total = new_total
    }
}


